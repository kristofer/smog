" Tower of Hanoi - Classic recursive algorithm "

Object subclass: #TowerOfHanoi [
    | moveCount |

    initialize [
        moveCount := 0.
    ]

    solve: n from: source to: destination aux: auxiliary [
        " Base case: only one disk to move "
        (n = 1) ifTrue: [
            moveCount := moveCount + 1.
            'Move ' print.
            moveCount print.
            ': Disk 1 from ' print.
            source print.
            ' to ' print.
            destination println.
        ] ifFalse: [
            " Recursive case: move n disks "

            " Step 1: Move n-1 disks from source to auxiliary using destination "
            self solve: (n - 1) from: source to: auxiliary aux: destination.

            " Step 2: Move the nth disk from source to destination "
            moveCount := moveCount + 1.
            'Move ' print.
            moveCount print.
            ': Disk ' print.
            n print.
            ' from ' print.
            source print.
            ' to ' print.
            destination println.

            " Step 3: Move n-1 disks from auxiliary to destination using source "
            self solve: (n - 1) from: auxiliary to: destination aux: source.
        ].
    ]

    getMoveCount [
        ^moveCount
    ]
]

" Solve Tower of Hanoi "
| n totalMoves solver expected power i |

'Tower of Hanoi' println.
'==============' println.
'' println.

" Create an instance of the solver "
solver := TowerOfHanoi new.
solver initialize.

n := 3.
'Solving Tower of Hanoi with ' print.
n print.
' disks...' println.
'' println.

solver solve: n from: 'A' to: 'C' aux: 'B'.

'' println.
'Total moves: ' print.
totalMoves := solver getMoveCount.
totalMoves println.

" Formula: 2^n - 1 "
'Expected moves: ' print.
power := 1.
i := 0.
[i < n] whileTrue: [
    power := power * 2.
    i := i + 1.
].
expected := power - 1.
expected println.
