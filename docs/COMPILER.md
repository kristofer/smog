# Smog Compiler Documentation

## Overview

The Smog compiler is responsible for transforming Abstract Syntax Trees (AST) into executable bytecode. It serves as the bridge between the high-level language structure and the low-level virtual machine instructions.

## Purpose and Role

The compiler sits in the middle of the Smog compilation pipeline:

```
Source Code → Lexer → Parser → AST → **COMPILER** → Bytecode → VM
```

Its primary responsibilities are:
1. **AST Traversal**: Walk through the abstract syntax tree produced by the parser
2. **Code Generation**: Emit bytecode instructions for each AST node
3. **Symbol Management**: Track variables and their storage locations
4. **Constant Management**: Build and maintain the constant pool
5. **Optimization**: (Future) Optimize generated bytecode for efficiency

## Key Concepts

### 1. Constant Pool

The constant pool is a collection of literal values referenced by bytecode instructions. Instead of embedding values directly in bytecode, we use indices:

**Without constant pool:**
```
PUSH "Hello"    ; Embeds entire string
PUSH 42         ; Direct value
```

**With constant pool:**
```
Constants: ["Hello", 42, "+"]
PUSH 0          ; Reference to constants[0]
PUSH 1          ; Reference to constants[1]
```

**Benefits:**
- Reduces bytecode size (reference small index vs. full value)
- Allows sharing of common values
- Simplifies VM implementation

### 2. Variable Storage

The compiler tracks two types of variables:

**Local Variables:**
- Declared within methods or blocks using `| var1 var2 |`
- Stored in a fixed-size array (indexed by position)
- Fast access via direct indexing
- Scoped to their defining block/method

**Global Variables:**
- Accessible from anywhere in the program
- Stored in a hash map (string name → value)
- Slower access but more flexible
- Persistent across method calls

### 3. Stack-Based Evaluation

All expressions evaluate to values pushed onto the stack:

```smog
3 + 4 * 5
```

Compiles to:
```
PUSH 3          ; Stack: [3]
PUSH 4          ; Stack: [3, 4]
PUSH 5          ; Stack: [3, 4, 5]
SEND *, 1       ; Stack: [3, 20]    (4 * 5)
SEND +, 1       ; Stack: [23]        (3 + 20)
```

## Compilation Process

### Step-by-Step Example

Let's compile this simple program:

```smog
| x y |
x := 10.
y := x + 5.
y println.
```

**Step 1: Symbol Table Setup**
- Register local variables: `x` → slot 0, `y` → slot 1

**Step 2: Compile Statements**

Statement: `x := 10`
```
PUSH 10         ; Load constant
STORE_LOCAL 0   ; Store to x (slot 0)
```

Statement: `y := x + 5`
```
LOAD_LOCAL 0    ; Load x
PUSH 5          ; Load constant
SEND +, 1       ; Send + message
STORE_LOCAL 1   ; Store to y (slot 1)
```

Statement: `y println`
```
LOAD_LOCAL 1    ; Load y
SEND println, 0 ; Send println message (0 args)
```

**Final Bytecode:**
```
Constants: [10, 5, "+", "println"]

0:  PUSH 0          ; Load 10
2:  STORE_LOCAL 0   ; x := 10
4:  LOAD_LOCAL 0    ; Load x
6:  PUSH 1          ; Load 5
8:  SEND 2, 1       ; Send + message (selector at index 2, 1 arg)
11: STORE_LOCAL 1   ; y := result
13: LOAD_LOCAL 1    ; Load y
15: SEND 3, 0       ; Send println (selector at index 3, 0 args)
```

## Message Sending

Message sending is the heart of Smog's object-oriented model. The compiler handles three types:

### 1. Unary Messages

```smog
array size
```

Compiles to:
```
LOAD_LOCAL 0    ; Load array
SEND size, 0    ; 0 arguments
```

### 2. Binary Messages

```smog
3 + 4
```

Compiles to:
```
PUSH 3          ; Receiver
PUSH 4          ; Argument
SEND +, 1       ; 1 argument
```

### 3. Keyword Messages

```smog
array at: 1 put: 'value'
```

Compiles to:
```
LOAD_LOCAL 0    ; Load array (receiver)
PUSH 1          ; First argument
PUSH 'value'    ; Second argument
SEND at:put:, 2 ; 2 arguments
```

## Blocks and Closures

Blocks are first-class objects that capture their environment:

```smog
| x makeIncrementer |
x := 10.
makeIncrementer := [ :amount | x := x + amount. x ].
```

**Compilation Strategy:**
1. Compile block body into separate bytecode sequence
2. Store captured variables in closure context
3. Emit PUSH_BLOCK instruction with block index

**Generated Bytecode:**
```
Main:
  PUSH 10
  STORE_LOCAL 0           ; x := 10
  PUSH_BLOCK 0            ; Create closure from block 0
  STORE_LOCAL 1           ; makeIncrementer := block

Block 0:
  LOAD_LOCAL 0            ; Load x (captured from outer scope)
  LOAD_ARG 0              ; Load amount parameter
  SEND +, 1               ; x + amount
  STORE_LOCAL 0           ; x := result
  LOAD_LOCAL 0            ; Return x
  RETURN
```

## Control Flow Compilation

Smog has no built-in control flow statements. Instead, control flow uses message passing to boolean objects:

### ifTrue: and ifFalse:

```smog
x > 0 ifTrue: [ 'positive' println ].
```

Compiles to:
```
LOAD_LOCAL 0        ; Load x
PUSH 0              ; Load 0
SEND >, 1           ; x > 0 (returns true/false object)
PUSH_BLOCK 0        ; Create block for then-clause
SEND ifTrue:, 1     ; Send ifTrue: message to boolean
```

The VM's implementation of `ifTrue:` on the `true` and `false` objects determines whether to evaluate the block.

### timesRepeat:

```smog
5 timesRepeat: [ 'hello' println ].
```

Compiles to:
```
PUSH 5              ; Receiver (integer)
PUSH_BLOCK 0        ; Block to repeat
SEND timesRepeat:, 1
```

## Class Compilation

Classes are compiled into method dictionaries:

```smog
Object subclass: #Counter [
    | count |
    
    initialize [
        count := 0.
    ]
    
    increment [
        count := count + 1.
    ]
]
```

**Compilation Output:**
- Class object with name "Counter"
- Instance variable list: ["count"]
- Method dictionary:
  - "initialize" → bytecode
  - "increment" → bytecode

## Optimization Opportunities (Future)

The compiler can be enhanced with various optimizations:

### 1. Constant Folding
Evaluate constant expressions at compile time:
```smog
x := 2 + 3 * 4.
```

Currently compiles to runtime calculation. Could optimize to:
```
PUSH 14         ; Pre-computed
STORE_LOCAL 0
```

### 2. Dead Code Elimination
Remove unreachable code:
```smog
method [
    ^5.
    'unreachable' println.  " Never executes "
]
```

### 3. Inline Caching
Cache method lookup results for frequently-called messages.

### 4. Peephole Optimization
Replace common instruction sequences with more efficient equivalents:
```
LOAD_LOCAL 0
LOAD_LOCAL 0
```
Could become:
```
LOAD_LOCAL 0
DUP
```

## Compiler API

### Creating a Compiler

```go
import "github.com/kristofer/smog/pkg/compiler"

c := compiler.New()
```

### Compiling an AST

```go
import (
    "github.com/kristofer/smog/pkg/parser"
    "github.com/kristofer/smog/pkg/compiler"
)

// Parse source to AST
p := parser.New(sourceCode)
ast, err := p.Parse()
if err != nil {
    log.Fatal(err)
}

// Compile AST to bytecode
c := compiler.New()
bytecode, err := c.Compile(ast)
if err != nil {
    log.Fatal(err)
}
```

### Inspecting Generated Bytecode

```go
// Print bytecode for debugging
fmt.Printf("Constants: %v\n", bytecode.Constants)
fmt.Printf("Instructions: %v\n", bytecode.Instructions)
```

## Error Handling

The compiler reports several types of errors:

### Undefined Variable
```smog
x := y + 1.  " Error: y is not defined "
```

### Invalid Assignment Target
```smog
5 := 10.  " Error: cannot assign to literal "
```

### Type Errors (Future)
With optional type checking:
```smog
x := 'hello' + 5.  " Error: incompatible types "
```

## Testing the Compiler

Example test structure:

```go
func TestCompileAssignment(t *testing.T) {
    input := "| x | x := 42."
    
    p := parser.New(input)
    ast, _ := p.Parse()
    
    c := compiler.New()
    bc, err := c.Compile(ast)
    
    if err != nil {
        t.Fatalf("Compilation failed: %v", err)
    }
    
    // Verify bytecode structure
    // Expected: PUSH 42, STORE_LOCAL 0
    expectedOpcodes := []Opcode{OpPush, OpStoreLocal}
    // ... verification logic
}
```

## Internal Architecture

### Symbol Table Structure

```go
type SymbolTable struct {
    symbols map[string]int      // var name → slot index
    outer   *SymbolTable         // parent scope
}
```

### Compilation Context

```go
type Compiler struct {
    constants []interface{}      // Constant pool
    symbols   *SymbolTable        // Current scope symbols
    bytecode  []Instruction       // Generated instructions
}
```

## Best Practices

1. **Keep symbol tables immutable**: Create new tables for nested scopes
2. **Use constant pool aggressively**: Even for small values
3. **Emit readable bytecode**: Use descriptive selector names in constants
4. **Validate before compiling**: Catch semantic errors early
5. **Test edge cases**: Empty blocks, deeply nested scopes, etc.

## Related Documentation

- [Parser Documentation](PARSER.md) - How AST is created
- [Bytecode Documentation](BYTECODE_GENERATION.md) - Bytecode format details
- [VM Documentation](VM_DEEP_DIVE.md) - How bytecode executes
- [Language Specification](spec/LANGUAGE_SPEC.md) - Language semantics

## Summary

The Smog compiler transforms high-level object-oriented code into efficient bytecode instructions. It manages variables, builds constant pools, and handles the complexities of message passing and closures. Understanding the compiler is key to understanding how Smog programs execute efficiently on the virtual machine.
