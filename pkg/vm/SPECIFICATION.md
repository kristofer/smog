# Smog Virtual Machine Specification

Version 0.1.0

## Abstract

This document specifies the design and operation of the Smog Virtual Machine (VM), a stack-based bytecode interpreter for executing Smog programs. The VM provides the runtime environment for bytecode generated by the Smog compiler.

## 1. Architecture

### 1.1 Overview

The Smog VM is a stack-based virtual machine that executes bytecode instructions. It maintains:

- An operand stack for computation
- Local variable storage
- Global variable storage
- A constant pool for literals
- An instruction pointer for execution control

### 1.2 Memory Model

#### 1.2.1 Execution Stack

- **Type**: Array of `interface{}`
- **Size**: 1024 slots
- **Purpose**: Stores operands, intermediate values, and computation results
- **Access**: LIFO (Last-In-First-Out)
- **Pointer**: Stack pointer (`sp`) tracks the next free slot

Stack operations:
- `push(value)`: Places value at `stack[sp]`, increments `sp`
- `pop()`: Decrements `sp`, returns `stack[sp]`
- Stack overflow occurs when `sp >= 1024`
- Stack underflow occurs when `sp <= 0` during pop

#### 1.2.2 Local Variables

- **Type**: Array of `interface{}`
- **Size**: 256 slots
- **Purpose**: Stores method-local variables
- **Lifecycle**: Reset at the start of each `Run()` call
- **Indexing**: Zero-based, accessed via operand index

#### 1.2.3 Global Variables

- **Type**: Map[string]interface{}
- **Purpose**: Stores globally accessible variables
- **Lifecycle**: Persists across `Run()` calls
- **Access**: By name (string key)

#### 1.2.4 Constants Pool

- **Type**: Array of `interface{}`
- **Source**: Provided by the bytecode object
- **Purpose**: Stores literal values (numbers, strings, symbols)
- **Access**: Read-only, indexed by instruction operands

### 1.3 Execution Model

The VM uses a fetch-decode-execute cycle:

1. **Fetch**: Read instruction at current instruction pointer (IP)
2. **Decode**: Determine opcode and extract operand
3. **Execute**: Perform the operation
4. **Advance**: Move IP to next instruction (or jump to specified location)

Execution continues until:
- An `OpReturn` instruction is encountered
- An error occurs
- All instructions have been executed

## 2. Instruction Set

### 2.1 Stack Operations

#### OpPush (0x00)
**Format**: `PUSH index`
**Operation**: Pushes constant at `constants[index]` onto stack
**Stack**: `... → ..., value`
**Errors**: Constant index out of bounds, stack overflow

#### OpPop (0x01)
**Format**: `POP`
**Operation**: Removes top value from stack
**Stack**: `..., value → ...`
**Errors**: Stack underflow

### 2.2 Literal Operations

#### OpPushTrue (0x20)
**Format**: `PUSH_TRUE`
**Operation**: Pushes boolean `true` onto stack
**Stack**: `... → ..., true`
**Errors**: Stack overflow

#### OpPushFalse (0x21)
**Format**: `PUSH_FALSE`
**Operation**: Pushes boolean `false` onto stack
**Stack**: `... → ..., false`
**Errors**: Stack overflow

#### OpPushNil (0x1F)
**Format**: `PUSH_NIL`
**Operation**: Pushes `nil` value onto stack
**Stack**: `... → ..., nil`
**Errors**: Stack overflow

### 2.3 Variable Operations

#### OpLoadLocal (0x06)
**Format**: `LOAD_LOCAL index`
**Operation**: Pushes local variable at `locals[index]` onto stack
**Stack**: `... → ..., value`
**Errors**: Local index out of bounds, stack overflow

#### OpStoreLocal (0x07)
**Format**: `STORE_LOCAL index`
**Operation**: Pops value from stack, stores in `locals[index]`, pushes value back
**Stack**: `..., value → ..., value`
**Errors**: Stack underflow, local index out of bounds, stack overflow
**Note**: Assignment returns the assigned value

#### OpLoadGlobal (0x0A)
**Format**: `LOAD_GLOBAL nameIndex`
**Operation**: 
1. Gets name from `constants[nameIndex]` (must be string)
2. Looks up value in globals map
3. Pushes value onto stack
**Stack**: `... → ..., value`
**Errors**: Constant index out of bounds, name not a string, undefined global, stack overflow

#### OpStoreGlobal (0x0B)
**Format**: `STORE_GLOBAL nameIndex`
**Operation**:
1. Gets name from `constants[nameIndex]` (must be string)
2. Pops value from stack
3. Stores in globals map
4. Pushes value back onto stack
**Stack**: `..., value → ..., value`
**Errors**: Stack underflow, constant index out of bounds, name not a string, stack overflow
**Note**: Assignment returns the assigned value

### 2.4 Message Send Operations

#### OpSend (0x03)
**Format**: `SEND operand`
**Operation**: Sends message to receiver with arguments
**Operand Encoding**:
```
operand = (selectorIndex << 8) | argCount
selectorIndex = operand >> 8
argCount = operand & 0xFF
```
**Execution**:
1. Decode selector index and argument count from operand
2. Get selector name from `constants[selectorIndex]`
3. Pop `argCount` arguments from stack (in reverse order)
4. Pop receiver from stack
5. Execute message send
6. Push result onto stack

**Stack**: `..., receiver, arg1, ..., argN → ..., result`
**Errors**: Selector index out of bounds, selector not a string, stack underflow, unknown message, operation-specific errors

### 2.5 Control Flow Operations

#### OpReturn (0x0E)
**Format**: `RETURN`
**Operation**: Terminates execution, leaves top of stack as result
**Stack**: No change
**Errors**: None

## 3. Message Dispatch

### 3.1 Primitive Messages

The VM implements primitive operations as built-in message handlers:

#### Arithmetic Messages
- `+` (add): Adds two numbers (int64 or float64)
- `-` (subtract): Subtracts two numbers
- `*` (multiply): Multiplies two numbers
- `/` (divide): Divides two numbers (error on division by zero)

**Type Requirements**: Both operands must be the same numeric type (no automatic type coercion)
**Returns**: Same type as operands
**Errors**: Type mismatch, division by zero

#### Comparison Messages
- `<` (less than): Compares two numbers
- `>` (greater than): Compares two numbers
- `<=` (less or equal): Compares two numbers
- `>=` (greater or equal): Compares two numbers
- `=` (equal): Tests equality of any two values
- `~=` (not equal): Tests inequality of any two values

**Type Requirements**: Numeric comparisons require same type
**Returns**: Boolean (true or false)
**Errors**: Type mismatch for numeric comparisons

#### I/O Messages
- `println`: Prints receiver to stdout with newline, returns receiver
- `print`: Prints receiver to stdout without newline, returns receiver

**Accepts**: Any value
**Returns**: The receiver
**Side Effects**: Output to stdout

### 3.2 Message Send Semantics

1. **Evaluation Order**: Arguments evaluated left-to-right before receiver
2. **Return Value**: Every message send returns a value (may be nil)
3. **Error Handling**: Errors propagate up, terminating execution
4. **Type Checking**: Performed at runtime during message execution

## 4. Type System

### 4.1 Supported Types

The VM uses Go's type system internally:

- `int64`: Integer numbers
- `float64`: Floating-point numbers
- `bool`: Boolean values (true, false)
- `string`: Text strings
- `nil`: Null/undefined value
- `interface{}`: Generic value container

### 4.2 Type Coercion

Currently, the VM does **not** perform automatic type coercion:
- `int64` and `float64` are not interchangeable
- Operations require exact type matches
- Type mismatches result in runtime errors

### 4.3 Type Checking

- Type checking is performed at runtime
- Type errors are reported as execution errors
- No static type analysis is performed

## 5. Error Handling

### 5.1 Error Types

The VM may encounter these errors:

1. **Stack Errors**
   - Stack overflow: `sp >= 1024`
   - Stack underflow: `sp <= 0` during pop

2. **Index Errors**
   - Constant index out of bounds
   - Local variable index out of bounds

3. **Variable Errors**
   - Undefined global variable
   - Invalid constant type for variable name

4. **Operation Errors**
   - Type mismatch in arithmetic/comparison
   - Division by zero
   - Unknown message selector

5. **Instruction Errors**
   - Unknown opcode

### 5.2 Error Propagation

- Errors halt execution immediately
- Error returned from `Run()` method
- Stack state preserved at error point
- No exception handling or recovery mechanism

## 6. Execution Lifecycle

### 6.1 Initialization

```go
vm := New()
```
Creates VM with:
- Empty stack (sp = 0)
- Nil-initialized local variables
- Empty global variables map
- No constants loaded

### 6.2 Execution

```go
err := vm.Run(bytecode)
```
Executes bytecode:
1. Resets stack pointer to 0
2. Clears local variables
3. Loads constants from bytecode
4. Executes instructions sequentially
5. Returns nil on success or error on failure

### 6.3 Result Retrieval

```go
result := vm.StackTop()
```
Returns top stack value without modifying stack:
- Returns `nil` if stack is empty
- Does not pop the value
- Safe to call after execution

## 7. Limitations and Constraints

### 7.1 Current Limitations

- **Fixed Stack Size**: 1024 slots, not configurable
- **Fixed Local Storage**: 256 slots, not configurable
- **No Garbage Collection**: Memory managed by Go runtime
- **No Call Frames**: Single execution context (no method calls yet)
- **No Block Closures**: Blocks not yet implemented
- **No Object System**: Primitive messages only
- **No Jump Instructions**: Control flow limited
- **Single-threaded**: No concurrency support

### 7.2 Resource Limits

- Maximum stack depth: 1024
- Maximum local variables: 256
- Maximum constants: Limited by Go slice capacity
- Maximum global variables: Limited by Go map capacity

## 8. Future Enhancements

Planned additions to the VM:

1. **Call Frames**: Support for method invocation and returns
2. **Block Closures**: First-class closures with lexical scoping
3. **Object System**: Object creation, field access, method lookup
4. **Jump Instructions**: Conditional and unconditional jumps
5. **Exception Handling**: Try-catch-finally mechanisms
6. **Garbage Collection**: Explicit memory management
7. **Optimizations**: JIT compilation, inline caching
8. **Debugging Support**: Breakpoints, stack traces, inspection

## 9. Maintenance Note

**Important**: This specification must be kept synchronized with the VM implementation. When changes are made to:

- Instruction set (new opcodes)
- Stack or memory model
- Message dispatch mechanism
- Error handling
- Type system

This document should be updated to reflect those changes. Consider creating a separate issue to update this specification when working on VM-related issues if the documentation update is not included in the current work.

## 10. References

- **Implementation**: [vm.go](vm.go)
- **Tests**: [vm_test.go](vm_test.go)
- **Bytecode Spec**: [../bytecode/bytecode.go](../bytecode/bytecode.go)
- **Language Spec**: [../../docs/spec/LANGUAGE_SPEC.md](../../docs/spec/LANGUAGE_SPEC.md)
- **Architecture**: [../../docs/design/ARCHITECTURE.md](../../docs/design/ARCHITECTURE.md)

## Appendix A: Instruction Reference Table

| Opcode | Name | Operand | Stack Effect | Description |
|--------|------|---------|--------------|-------------|
| 0x00 | PUSH | index | `... → ..., value` | Push constant |
| 0x01 | POP | - | `..., value → ...` | Pop and discard |
| 0x03 | SEND | encoded | `..., rcv, args → ..., result` | Message send |
| 0x06 | LOAD_LOCAL | index | `... → ..., value` | Load local var |
| 0x07 | STORE_LOCAL | index | `..., value → ..., value` | Store local var |
| 0x0A | LOAD_GLOBAL | nameIdx | `... → ..., value` | Load global var |
| 0x0B | STORE_GLOBAL | nameIdx | `..., value → ..., value` | Store global var |
| 0x0E | RETURN | - | No change | End execution |
| 0x1F | PUSH_NIL | - | `... → ..., nil` | Push nil |
| 0x20 | PUSH_TRUE | - | `... → ..., true` | Push true |
| 0x21 | PUSH_FALSE | - | `... → ..., false` | Push false |

## Appendix B: Message Reference Table

| Selector | Arity | Operand Types | Return Type | Description |
|----------|-------|---------------|-------------|-------------|
| `+` | 1 | int64/float64 | Same as operands | Addition |
| `-` | 1 | int64/float64 | Same as operands | Subtraction |
| `*` | 1 | int64/float64 | Same as operands | Multiplication |
| `/` | 1 | int64/float64 | Same as operands | Division |
| `<` | 1 | int64/float64 | bool | Less than |
| `>` | 1 | int64/float64 | bool | Greater than |
| `<=` | 1 | int64/float64 | bool | Less or equal |
| `>=` | 1 | int64/float64 | bool | Greater or equal |
| `=` | 1 | any | bool | Equality test |
| `~=` | 1 | any | bool | Inequality test |
| `println` | 0 | any | Same as receiver | Print with newline |
| `print` | 0 | any | Same as receiver | Print without newline |
