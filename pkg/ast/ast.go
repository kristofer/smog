// Package ast defines the Abstract Syntax Tree nodes for smog.
//
// The AST is an intermediate representation of the source code that bridges
// the gap between the raw text (handled by the lexer) and the executable
// bytecode (generated by the compiler). Each node in the tree represents a
// syntactic construct in the language.
//
// Design Philosophy:
// - Each AST node corresponds to a grammatical rule in the language
// - Nodes are organized hierarchically: Program -> Statements -> Expressions
// - All nodes implement the Node interface for uniform handling
// - The tree structure preserves the semantic meaning of the code
//
// Node Hierarchy:
//   Program (root)
//     ├─ Statements (actions to perform)
//     │   ├─ ExpressionStatement (expression used as statement)
//     │   ├─ VariableDeclaration (| x y z |)
//     │   └─ Class (class definition)
//     └─ Expressions (values and computations)
//         ├─ Literals (constants: 42, "hello", true, nil)
//         ├─ Identifier (variable reference: x)
//         ├─ Assignment (x := value)
//         └─ MessageSend (receiver selector: arg)
package ast

// SourceLocation tracks the source position of an AST node.
// This is used for error reporting and debugging.
type SourceLocation struct {
	Line   int // Line number in source (1-based)
	Column int // Column number in source (1-based)
}

// Node is the interface that all AST nodes implement.
//
// Every construct in the smog language - whether a class definition,
// a variable declaration, or a simple number - is represented as a Node
// in the AST. This common interface allows us to traverse and manipulate
// the tree uniformly.
//
// The TokenLiteral() method returns a string representation useful for
// debugging and error messages.
type Node interface {
	TokenLiteral() string
}

// Expression represents an expression node.
//
// Expressions are constructs that evaluate to a value. In smog, nearly
// everything is an expression - even things that might be statements in
// other languages (like assignments) are expressions that return values.
//
// Examples of expressions:
//   - Literals: 42, "hello", true, nil
//   - Identifiers: x, myVariable
//   - Assignments: x := 10 (returns 10)
//   - Message sends: 3 + 4 (returns 7)
//
// The expressionNode() method is a marker - it exists only to distinguish
// Expression nodes from Statement nodes at compile time.
type Expression interface {
	Node
	expressionNode()
}

// Statement represents a statement node.
//
// Statements are top-level constructs that perform actions but don't
// necessarily produce values for further computation. In smog, statements
// appear at the program level and within method/block bodies.
//
// Examples of statements:
//   - Variable declarations: | x y z |
//   - Expression statements: 3 + 4. (expression used as statement)
//   - Class definitions: Object subclass: #MyClass [...]
//
// The statementNode() method is a marker to distinguish Statement nodes
// from Expression nodes at compile time.
type Statement interface {
	Node
	statementNode()
}

// Program represents the root node of the AST.
//
// A Program is the top-level container for all code in a smog source file.
// It consists of a sequence of statements that are executed in order.
//
// Example source code:
//   | x y |        <- VariableDeclaration statement
//   x := 5.        <- ExpressionStatement (Assignment expression)
//   y := 10.       <- ExpressionStatement (Assignment expression)
//   x + y.         <- ExpressionStatement (MessageSend expression)
//
// This would create a Program with 4 statements in the Statements slice.
type Program struct {
	Statements []Statement
}

// TokenLiteral returns the token literal of the first statement.
// This is primarily used for debugging and error reporting.
func (p *Program) TokenLiteral() string {
	if len(p.Statements) > 0 {
		return p.Statements[0].TokenLiteral()
	}
	return ""
}

// ExpressionStatement wraps an expression to use it as a statement.
//
// In smog, expressions can appear at the statement level. For example:
//   3 + 4.
//   'Hello' println.
//   x := 10.
//
// Each of these is an expression (evaluating to a value) but used as a
// statement (for its side effects or as a top-level action). The period
// at the end marks the statement boundary.
//
// The ExpressionStatement node allows expressions to appear in positions
// where statements are expected (like at the program level or in method bodies).
type ExpressionStatement struct {
	Expression Expression
	Loc        SourceLocation
}

// TokenLiteral returns the token literal of the wrapped expression.
func (es *ExpressionStatement) TokenLiteral() string {
	return es.Expression.TokenLiteral()
}
func (es *ExpressionStatement) statementNode() {}

// VariableDeclaration declares one or more local variables.
//
// Syntax: | varName1 varName2 ... |
//
// Variable declarations appear at the beginning of a scope (program level,
// method body, or block body) and reserve space for local variables.
//
// Example:
//   | x y sum |
//
// This creates a VariableDeclaration node with Names = ["x", "y", "sum"].
// The variables are initially nil until assigned values.
//
// Note: Variable declarations don't generate bytecode themselves - they just
// inform the compiler to allocate local variable slots.
type VariableDeclaration struct {
	Names []string       // List of variable names being declared
	Loc   SourceLocation // Source location of the declaration
}

// TokenLiteral returns an empty string since variable declarations
// don't correspond to a specific token.
func (vd *VariableDeclaration) TokenLiteral() string { return "" }
func (vd *VariableDeclaration) statementNode()       {}

// Assignment represents a variable assignment expression.
//
// Syntax: variableName := value
//
// Assignments bind a value to a variable. In smog, assignment is an
// expression that returns the assigned value, allowing chained assignments
// and using assignments in larger expressions.
//
// Example:
//   x := 10           <- Assigns 10 to x and returns 10
//   y := x := 5       <- Assigns 5 to both x and y
//   (z := 3) + 2      <- Assigns 3 to z and evaluates to 5
//
// The compiler will check if the variable is local (in the symbol table)
// or global, and emit the appropriate STORE instruction.
type Assignment struct {
	Name  string         // Name of the variable being assigned
	Value Expression     // Expression whose value will be assigned
	Loc   SourceLocation // Source location of the assignment
}

// TokenLiteral returns the variable name being assigned.
func (a *Assignment) TokenLiteral() string { return a.Name }
func (a *Assignment) expressionNode()      {}

// IntegerLiteral represents an integer constant in the source code.
//
// Syntax: 42, 0, -17, 1000
//
// Integer literals are whole numbers. They are parsed from the source text
// and stored as int64 values. Negative numbers are handled as unary message
// sends of the negation operator to positive numbers.
//
// Example:
//   42 -> IntegerLiteral{Value: 42}
//
// The compiler will add the integer value to the constant pool and emit
// a PUSH instruction to load it onto the stack at runtime.
type IntegerLiteral struct {
	Value int64          // The integer value
	Loc   SourceLocation // Source location of the literal
}

// TokenLiteral returns an empty string (the value itself is in the Value field).
func (il *IntegerLiteral) TokenLiteral() string { return "" }
func (il *IntegerLiteral) expressionNode()      {}

// FloatLiteral represents a floating-point constant in the source code.
//
// Syntax: 3.14, 0.5, 2.718
//
// Float literals represent decimal numbers with fractional parts. They are
// stored as float64 values.
//
// Example:
//   3.14 -> FloatLiteral{Value: 3.14}
//
// The compiler will add the float value to the constant pool and emit
// a PUSH instruction to load it onto the stack at runtime.
type FloatLiteral struct {
	Value float64 // The floating-point value
}

// TokenLiteral returns an empty string (the value itself is in the Value field).
func (fl *FloatLiteral) TokenLiteral() string { return "" }
func (fl *FloatLiteral) expressionNode()      {}

// StringLiteral represents a string constant in the source code.
//
// Syntax: 'Hello, World!'
//
// String literals are sequences of characters enclosed in single quotes.
// They represent immutable text values.
//
// Example:
//   'Hello' -> StringLiteral{Value: "Hello"}
//
// Note: The quotes are not stored in the Value - only the actual string content.
// The compiler will add the string to the constant pool and emit a PUSH instruction.
type StringLiteral struct {
	Value string // The string content (without quotes)
}

// TokenLiteral returns the string value itself.
func (sl *StringLiteral) TokenLiteral() string { return sl.Value }
func (sl *StringLiteral) expressionNode()      {}

// BooleanLiteral represents a boolean constant (true or false).
//
// Syntax: true, false
//
// Boolean literals represent truth values. They are the foundation of
// conditional logic in smog.
//
// Examples:
//   true  -> BooleanLiteral{Value: true}
//   false -> BooleanLiteral{Value: false}
//
// The compiler emits specialized PUSH_TRUE or PUSH_FALSE instructions
// rather than using the constant pool, for efficiency.
type BooleanLiteral struct {
	Value bool // true or false
}

// TokenLiteral returns "true" or "false" based on the value.
func (bl *BooleanLiteral) TokenLiteral() string {
	if bl.Value {
		return "true"
	}
	return "false"
}
func (bl *BooleanLiteral) expressionNode() {}

// NilLiteral represents the nil value.
//
// Syntax: nil
//
// Nil is the representation of "nothing" or "no value" in smog. It's
// similar to null in other languages. Uninitialized variables start as nil.
//
// Example:
//   nil -> NilLiteral{}
//
// The compiler emits a specialized PUSH_NIL instruction.
type NilLiteral struct{}

// TokenLiteral returns "nil".
func (nl *NilLiteral) TokenLiteral() string { return "nil" }
func (nl *NilLiteral) expressionNode()      {}

// Identifier represents a reference to a variable.
//
// Syntax: variableName
//
// Identifiers refer to variables that have been declared. When encountered,
// the compiler looks up the variable in the symbol table to determine if
// it's a local or global variable, then emits the appropriate LOAD instruction.
//
// Example:
//   x -> Identifier{Name: "x"}
//
// At runtime, this will load the value of the variable onto the stack.
type Identifier struct {
	Name string         // The variable name
	Loc  SourceLocation // Source location of the identifier
}

// TokenLiteral returns the identifier name.
func (i *Identifier) TokenLiteral() string { return i.Name }
func (i *Identifier) expressionNode()      {}

// BlockLiteral represents a block (closure) literal.
//
// Syntax: [ statements... ]
//        or: [ :param1 :param2 | statements... ]
//
// Blocks are anonymous functions (closures) that can be passed around
// as values and executed later. They are fundamental to control flow
// and higher-order programming in smog.
//
// A block consists of:
//   - Parameters (optional): :x :y
//   - Body: sequence of statements
//
// Blocks can capture variables from their surrounding scope (closures).
//
// Examples:
//   [ 'Hello' println ]
//     -> BlockLiteral{Parameters: [], Body: [println message]}
//
//   [ :x | x * 2 ]
//     -> BlockLiteral{Parameters: ["x"], Body: [x * 2]}
//
//   [ :x :y | x + y ]
//     -> BlockLiteral{Parameters: ["x", "y"], Body: [x + y]}
//
// Execution:
//   Blocks are executed by sending them the 'value' message (no args)
//   or 'value:' message (with args):
//     block value
//     block value: 5
//     block value: 3 value: 7
type BlockLiteral struct {
	Parameters []string    // Parameter names (e.g., ["x", "y"])
	Body       []Statement // Statements in the block body
}

// TokenLiteral returns "block" to identify this as a block literal.
func (bl *BlockLiteral) TokenLiteral() string { return "block" }
func (bl *BlockLiteral) expressionNode()      {}

// ReturnStatement represents an explicit return from a method.
//
// Syntax: ^expression
//
// Return statements exit the current method and return a value to the caller.
// The caret (^) is the return operator.
//
// Examples:
//   ^5
//     -> ReturnStatement{Value: IntegerLiteral{5}}
//
//   ^x + y
//     -> ReturnStatement{Value: MessageSend{...}}
//
// Note: Methods implicitly return self if there's no explicit return.
// Blocks return the value of their last expression.
type ReturnStatement struct {
	Value Expression // The expression to return
}

// TokenLiteral returns "return" to identify this as a return statement.
func (rs *ReturnStatement) TokenLiteral() string { return "return" }
func (rs *ReturnStatement) statementNode()       {}

// ArrayLiteral represents an array literal.
//
// Syntax: #(element1 element2 ...)
//
// Array literals create arrays with the specified elements.
//
// Example:
//   #(1 2 3 4 5)
//     -> ArrayLiteral{Elements: [1, 2, 3, 4, 5]}
//
// Note: This is syntactic sugar for creating Array instances.
type ArrayLiteral struct {
	Elements []Expression // Elements of the array
}

// TokenLiteral returns "array" to identify this as an array literal.
func (al *ArrayLiteral) TokenLiteral() string { return "array" }
func (al *ArrayLiteral) expressionNode()      {}
//
// Syntax: SuperClass subclass: #ClassName [fields... methods...]
//
// Classes are the blueprints for creating objects. Each class definition
// specifies:
//   - A name (the class identifier, like #Counter)
//   - A superclass to inherit from (like Object)
//   - Instance variables (fields) that each instance will have
//   - Class variables (shared across all instances)
//   - Methods that define the behavior of instances
//   - Class methods (methods on the class itself)
//
// Example:
//   Object subclass: #Counter [
//       | count |                    " instance variable "
//       <| totalCount |>             " class variable "
//       initialize [ count := 0. ]   " instance method "
//       <incrementTotal [            " class method "
//           totalCount := totalCount + 1.
//       ]>
//   ]
//
// This creates a Class node with:
//   - Name: "Counter"
//   - SuperClass: "Object"
//   - Fields: ["count"]
//   - ClassVariables: ["totalCount"]
//   - Methods: [initialize method]
//   - ClassMethods: [incrementTotal method]
type Class struct {
	Name           string    // Class name (without the # prefix)
	SuperClass     string    // Name of the superclass
	Methods        []*Method // List of instance method definitions
	ClassMethods   []*Method // List of class method definitions
	Fields         []string  // List of instance variable names
	ClassVariables []string  // List of class variable names
}

// TokenLiteral returns "class" to identify this as a class definition.
func (c *Class) TokenLiteral() string { return "class" }
func (c *Class) statementNode()       {}

// Method represents a method definition within a class.
//
// Syntax: methodName [ body... ]
//        or: methodName: param [ body... ]
//        or: keyword1: param1 keyword2: param2 [ body... ]
//
// Methods define the behavior that objects of a class can perform. Each
// method has:
//   - A name (selector) - can be unary, binary, or keyword-based
//   - Parameters (for keyword and binary methods)
//   - A body consisting of statements
//
// Examples:
//   initialize [ count := 0. ]
//     -> Method{Name: "initialize", Parameters: [], Body: [assignment]}
//
//   value [ ^count ]
//     -> Method{Name: "value", Parameters: [], Body: [return statement]}
//
//   at: index put: value [ ... ]
//     -> Method{Name: "at:put:", Parameters: ["index", "value"], Body: [...]}
type Method struct {
	Name       string      // Method selector (e.g., "initialize", "at:put:")
	Parameters []string    // Parameter names for the method
	Body       []Statement // Statements in the method body
}

// TokenLiteral returns "method" to identify this as a method definition.
func (m *Method) TokenLiteral() string { return "method" }

// MessageSend represents sending a message to an object.
//
// Syntax: receiver selector
//        or: receiver binary_op argument
//        or: receiver keyword1: arg1 keyword2: arg2
//
// Message sending is THE fundamental operation in smog. All computation
// happens by sending messages to objects. A message send consists of:
//   - A receiver (the object receiving the message)
//   - A selector (the message name)
//   - Arguments (for binary and keyword messages)
//   - IsSuper flag (true if this is a super send)
//
// Types of messages:
//
// 1. Unary messages (no arguments):
//      'Hello' println
//      -> MessageSend{Receiver: 'Hello', Selector: "println", Args: []}
//
// 2. Binary messages (one argument, operator syntax):
//      3 + 4
//      -> MessageSend{Receiver: 3, Selector: "+", Args: [4]}
//
// 3. Keyword messages (one or more arguments):
//      array at: 1 put: 'value'
//      -> MessageSend{Receiver: array, Selector: "at:put:", Args: [1, 'value']}
//
// 4. Super message sends (starts lookup in superclass):
//      super initialize
//      -> MessageSend{Receiver: nil, Selector: "initialize", Args: [], IsSuper: true}
//
// Compilation:
// The compiler will:
//   1. Compile the receiver expression (pushes receiver on stack)
//   2. Compile each argument expression (pushes args on stack)
//   3. Emit a SEND or SUPER_SEND instruction with the selector and arg count
//
// Execution:
// The VM will:
//   1. Pop the arguments and receiver from the stack
//   2. Look up the method for the selector in the receiver's class (or superclass for super sends)
//   3. Execute the method with the arguments
//   4. Push the result back onto the stack
type MessageSend struct {
	Receiver Expression     // The object receiving the message (nil for super sends)
	Selector string         // The message selector (e.g., "+", "println", "at:put:")
	Args     []Expression   // Arguments to the message (empty for unary messages)
	IsSuper  bool           // true if this is a super message send
	Loc      SourceLocation // Source location of the message send
}

// TokenLiteral returns the selector of the message.
func (m *MessageSend) TokenLiteral() string { return m.Selector }
func (m *MessageSend) expressionNode()      {}

// CascadeExpression represents cascading messages to the same receiver.
//
// Syntax: receiver message1; message2; message3
//
// Cascading allows sending multiple messages to the same object without
// repeating the receiver. The receiver is evaluated once, and each message
// is sent to that same object in sequence.
//
// Example:
//   point x: 10; y: 20; display
//     -> CascadeExpression{
//          Receiver: point,
//          Messages: [
//            MessageSend{Selector: "x:", Args: [10]},
//            MessageSend{Selector: "y:", Args: [20]},
//            MessageSend{Selector: "display", Args: []}
//          ]
//        }
//
// The cascade expression returns the receiver itself, not the result of
// the last message (unlike sequential message sends).
//
// Compilation:
//   1. Compile and push the receiver
//   2. For each message except the last: DUP, compile message send, POP
//   3. For the last message: compile message send, POP, push receiver
//
// This ensures the receiver is returned as the value of the cascade.
type CascadeExpression struct {
	Receiver Expression   // The object receiving all messages
	Messages []MessageSend // The messages to send (without receivers)
}

// TokenLiteral returns "cascade" to identify this as a cascade expression.
func (ce *CascadeExpression) TokenLiteral() string { return "cascade" }
func (ce *CascadeExpression) expressionNode()      {}

// DictionaryLiteral represents a dictionary literal.
//
// Syntax: #{ key1 -> value1. key2 -> value2. ... }
//
// Dictionary literals create dictionaries (hash maps) with the specified
// key-value pairs.
//
// Example:
//   #{ 'name' -> 'Alice'. 'age' -> 30 }
//     -> DictionaryLiteral{
//          Pairs: [
//            {'name', 'Alice'},
//            {'age', 30}
//          ]
//        }
//
// Note: This is syntactic sugar for creating Dictionary instances.
type DictionaryLiteral struct {
	Pairs []DictionaryPair // Key-value pairs in the dictionary
}

// DictionaryPair represents a key-value pair in a dictionary literal.
type DictionaryPair struct {
	Key   Expression // The key expression
	Value Expression // The value expression
}

// TokenLiteral returns "dictionary" to identify this as a dictionary literal.
func (dl *DictionaryLiteral) TokenLiteral() string { return "dictionary" }
func (dl *DictionaryLiteral) expressionNode()      {}
