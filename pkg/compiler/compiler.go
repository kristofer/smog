// Package compiler compiles AST nodes into bytecode.
//
// The compiler is the bridge between the high-level AST (Abstract Syntax Tree)
// representation and the low-level bytecode that the VM executes. It performs
// several key tasks:
//
//   1. Traverse the AST tree structure
//   2. Generate bytecode instructions for each node
//   3. Manage the constant pool (literals and identifiers)
//   4. Track variable declarations (symbol table)
//   5. Emit appropriate opcodes for each language construct
//
// Compilation Process:
//
//   Source Code → Lexer → Parser → AST → Compiler → Bytecode → VM
//
// The compiler walks the AST and emits a linear sequence of instructions.
// For example:
//
//   Source: | x | x := 5. x + 3.
//
//   AST:
//     Program
//       ├─ VariableDeclaration: ["x"]
//       ├─ ExpressionStatement
//       │   └─ Assignment: name="x", value=IntegerLiteral(5)
//       └─ ExpressionStatement
//           └─ MessageSend: receiver=Identifier("x"), selector="+", args=[IntegerLiteral(3)]
//
//   Bytecode:
//     PUSH 0          ; constant[0] = 5
//     STORE_LOCAL 0   ; x is at local slot 0
//     LOAD_LOCAL 0    ; load x
//     PUSH 1          ; constant[1] = 3
//     SEND 2, 1       ; constant[2] = "+", 1 argument
//     RETURN
//
//   Constants: [5, 3, "+"]
//
// Key Concepts:
//
// Symbol Table:
//   Maps variable names to local variable slot indices. When a variable is
//   declared with `| x y |`, the compiler assigns slots: x=0, y=1.
//
// Constant Pool:
//   Stores all literal values (numbers, strings) and identifiers (selectors,
//   global names) used in the program. Instructions reference these by index.
//
// Stack-Based Code Generation:
//   Most operations assume their operands are on the stack. For example,
//   `x + y` compiles to: LOAD x, LOAD y, SEND +
//
// Expression vs Statement Compilation:
//   Both produce values on the stack, but statement results may be discarded
//   if not needed.
package compiler

import (
	"fmt"

	"github.com/kristofer/smog/pkg/ast"
	"github.com/kristofer/smog/pkg/bytecode"
)

// Compiler represents the bytecode compiler with lexical scoping support.
//
// The compiler maintains state during compilation:
//   - instructions: The growing sequence of bytecode instructions
//   - constants: The constant pool of literal values
//   - localVars: Names of local variables declared in THIS scope (new for lexical scoping)
//   - localCount: Number of local variables in this scope
//   - capturedVars: Variables captured from parent scopes (new for lexical scoping)
//   - parent: Link to parent compiler for nested scopes (new for lexical scoping)
//   - fields: Map of instance/class variable names to field indices (used in methods)
//   - classVars: Class variable table
//   - classes: Registry of compiled classes
//   - inBlock: True if currently compiling inside a block
//
// Lexical Scoping:
//   The compiler now maintains an environment chain through the parent link.
//   When compiling a block, the compiler resolves variables by:
//   1. Checking local variables in the current scope
//   2. Checking captured variables (already resolved from parent)
//   3. Searching in the parent scope recursively
//   4. Checking fields, class vars, and globals
//
// Example of environment chain:
//   Top-level Compiler (parent = nil)
//     | localVars: [x, y]
//     v
//   Block Compiler (parent = top-level)
//     | localVars: [param1, temp1]
//     | capturedVars: [x from parent]
//     v
//   Nested Block Compiler (parent = block)
//     | localVars: [param2]
//     | capturedVars: [x from grandparent, temp1 from parent]
//
// The compiler is stateful and single-use: create a new compiler for
// each compilation unit (program, method, block).
type Compiler struct {
	instructions []bytecode.Instruction                 // Generated bytecode instructions
	constants    []interface{}                          // Constant pool (literals, names)
	localVars    []string                               // Local variable names (this scope only)
	localCount   int                                    // Number of local variables in this scope
	capturedVars []bytecode.CapturedVar                 // Variables captured from parent scopes
	parent       *Compiler                              // Parent compiler (nil for top-level)
	fields       map[string]int                         // Field table: field name -> field index
	classVars    map[string]int                         // Class variable table: name -> index
	classes      map[string]*bytecode.ClassDefinition   // Registry of compiled classes
	inBlock      bool                                   // True if currently compiling inside a block
}

// New creates a new compiler instance.
//
// Each compilation starts with a fresh compiler that has:
//   - Empty instruction sequence
//   - Empty constant pool
//   - Empty symbol table
//   - Zero local variables
//   - Empty field table
func New() *Compiler {
	return &Compiler{
		instructions: make([]bytecode.Instruction, 0),
		constants:    make([]interface{}, 0),
		localVars:    make([]string, 0),
		capturedVars: make([]bytecode.CapturedVar, 0),
		localCount:   0,
		parent:       nil,
		fields:       make(map[string]int),
		classVars:    make(map[string]int),
		classes:      make(map[string]*bytecode.ClassDefinition),
	}
}

// Compile compiles an AST program into bytecode.
//
// This is the main entry point for compilation. It:
//   1. Processes each statement in the program sequentially
//   2. Emits bytecode for each statement
//   3. Adds a final RETURN instruction to end execution
//   4. Returns the complete Bytecode with instructions and constants
//
// Example:
//
//   parser := parser.New("3 + 4.")
//   program, _ := parser.Parse()
//   compiler := compiler.New()
//   bytecode, _ := compiler.Compile(program)
//
// The resulting bytecode can then be executed by the VM.
//
// Returns an error if any statement fails to compile (e.g., unknown node type).
func (c *Compiler) Compile(program *ast.Program) (*bytecode.Bytecode, error) {
	// Compile each statement in order
	for i, stmt := range program.Statements {
		isLast := i == len(program.Statements)-1
		if err := c.compileStatementWithContext(stmt, isLast); err != nil {
			return nil, err
		}
	}

	// Add final return instruction to end the program
	c.emit(bytecode.OpReturn, 0)

	return &bytecode.Bytecode{
		Instructions: c.instructions,
		Constants:    c.constants,
	}, nil
}

// compileStatementWithContext compiles a single statement with context about its position.
//
// The isLast parameter indicates whether this is the last statement in the current scope.
// For expression statements that are not the last statement, we emit a POP instruction
// to discard the result and keep the stack clean.
//
// This prevents stack corruption when multiple expression statements are executed
// in sequence, such as:
//   numbers do: [ :each | each println ].  " Result left on stack without POP "
//   | x |  " Next statement would see corrupted stack "
func (c *Compiler) compileStatementWithContext(stmt ast.Statement, isLast bool) error {
	switch s := stmt.(type) {
	case *ast.ExpressionStatement:
		// Compile the wrapped expression
		if err := c.compileExpression(s.Expression); err != nil {
			return err
		}
		// Pop the result from the stack if this is not the last statement
		// The last statement's value is kept on the stack as the return value
		if !isLast {
			c.emit(bytecode.OpPop, 0)
		}
		return nil

	case *ast.VariableDeclaration:
		// Variable declarations don't generate bytecode directly.
		// They just reserve space in the local variable array and
		// add variables to the local scope.
		//
		// Example: | x y z |
		//   -> localVars = ["x", "y", "z"]
		//   -> localCount = 3
		//
		// The variables are initialized to nil at runtime.
		for _, name := range s.Names {
			c.localVars = append(c.localVars, name)
			c.localCount++
		}
		return nil

	case *ast.ReturnStatement:
		// Return statements compile the return value and emit RETURN or NON_LOCAL_RETURN.
		//
		// Process:
		//   1. Compile the return value expression
		//   2. Emit appropriate return instruction:
		//      - OpNonLocalReturn if inside a block (returns from the creating method)
		//      - OpReturn if at method/top level (local return)
		//
		// The distinction is crucial for Smalltalk semantics:
		//   - In a block: ^value exits the method that created the block
		//   - In a method: ^value exits the method normally
		//
		// Example in a block: condition ifTrue: [ ^42 ]
		//   -> compile "42" (leaves result on stack)
		//   -> NON_LOCAL_RETURN (exits the enclosing method, not just the block)
		//
		// Example in a method: myMethod [ ^42 ]
		//   -> compile "42" (leaves result on stack)
		//   -> RETURN (exits the method normally)
		if err := c.compileExpression(s.Value); err != nil {
			return err
		}
		
		if c.inBlock {
			// Inside a block: use non-local return to exit the enclosing method
			c.emit(bytecode.OpNonLocalReturn, 0)
		} else {
			// At method/top level: use normal return
			c.emit(bytecode.OpReturn, 0)
		}
		return nil

	case *ast.Class:
		// Class definitions create a ClassDefinition and emit OpDefineClass.
		//
		// Process:
		//   1. Compile each method's bytecode
		//   2. Create ClassDefinition with metadata and methods
		//   3. Add ClassDefinition to constant pool
		//   4. Emit DEFINE_CLASS instruction
		//
		// Example: Object subclass: #Counter [ ... ]
		//   -> ClassDefinition in constants
		//   -> DEFINE_CLASS idx
		return c.compileClass(s)

	default:
		return fmt.Errorf("unknown statement type: %T", stmt)
	}
}

// compileStatement compiles a single statement without last-statement context.
//
// This is a wrapper around compileStatementWithContext that passes isLast=true.
// It's used in contexts where statements should keep their values on the stack,
// such as:
//   - Method bodies (methods return the last expression's value)
//   - Block bodies (blocks return the last expression's value)
//
// For top-level program compilation where intermediate results should be discarded,
// use compileStatementWithContext with appropriate isLast values instead.
func (c *Compiler) compileStatement(stmt ast.Statement) error {
	// In method/block contexts, we want to keep the last expression's value
	// on the stack, so we pass isLast=true to avoid emitting POP.
	// This matches the semantics of methods and blocks which return
	// their last expression's value.
	return c.compileStatementWithContext(stmt, true)
}


// compileExpression compiles an expression node.
//
// Expressions produce values. When compiled, they generate bytecode that
// evaluates the expression and leaves the result on the stack.
//
// The compiler handles each expression type differently:
//
//   Literals:
//     Add the value to the constant pool and emit PUSH instruction
//     Example: 42 -> PUSH index_of_42_in_constants
//
//   Identifiers:
//     Look up in symbol table and emit LOAD instruction
//     Example: x -> LOAD_LOCAL 0 (if x is local slot 0)
//
//   Assignments:
//     Compile the value expression, then emit STORE instruction
//     Example: x := 5 -> PUSH 5; STORE_LOCAL 0
//
//   Message Sends:
//     Compile receiver, compile arguments, emit SEND instruction
//     Example: 3 + 4 -> PUSH 3; PUSH 4; SEND +, 1
//
//   Blocks:
//     Create a separate bytecode for the block body, add to constants
//     Example: [ x + 1 ] -> MAKE_CLOSURE block_index, 0
//
// All expression compilation follows the pattern:
//   1. Compile sub-expressions (leaves values on stack)
//   2. Emit operation instruction
//   3. Result is left on stack for parent expression/statement
func (c *Compiler) compileExpression(expr ast.Expression) error {
	switch e := expr.(type) {
	case *ast.IntegerLiteral:
		// Integer literals are stored in the constant pool.
		// We add the value to the pool and emit a PUSH instruction
		// with the index.
		//
		// Example: 42
		//   -> constants = [42]
		//   -> PUSH 0
		idx := c.addConstant(e.Value)
		c.emit(bytecode.OpPush, idx)
		return nil

	case *ast.FloatLiteral:
		// Float literals work the same as integers.
		//
		// Example: 3.14
		//   -> constants = [3.14]
		//   -> PUSH 0
		idx := c.addConstant(e.Value)
		c.emit(bytecode.OpPush, idx)
		return nil

	case *ast.StringLiteral:
		// String literals are also stored in the constant pool.
		//
		// Example: 'Hello'
		//   -> constants = ["Hello"]
		//   -> PUSH 0
		idx := c.addConstant(e.Value)
		c.emit(bytecode.OpPush, idx)
		return nil

	case *ast.BooleanLiteral:
		// Boolean literals use specialized instructions for efficiency.
		// Instead of adding true/false to the constant pool, we use
		// dedicated opcodes.
		//
		// This saves space (no constant pool entry) and is faster
		// (no constant pool lookup at runtime).
		if e.Value {
			c.emit(bytecode.OpPushTrue, 0)
		} else {
			c.emit(bytecode.OpPushFalse, 0)
		}
		return nil

	case *ast.NilLiteral:
		// Nil also uses a specialized instruction.
		c.emit(bytecode.OpPushNil, 0)
		return nil

	case *ast.Identifier:
		// Identifiers refer to variables. We look up the variable in
		// the symbol table to determine if it's local, a field, or global.
		//
		// Special case: 'self' keyword
		//   Pushes the current receiver (self)
		//   Example: self
		//     -> PUSH_SELF
		//
		// Local variables:
		//   Stored in the symbol table with their slot index
		//   Example: x (where x was declared as | x |)
		//     -> LOAD_LOCAL slot_index
		//
		// Instance/class variables (fields):
		//   Stored in the fields map with their field index
		//   Example: count (where count is an instance variable)
		//     -> LOAD_FIELD field_index
		//
		// Global variables:
		//   Not in the symbol table or fields map (not declared locally)
		//   Example: SomeClass
		//     -> constants = ["SomeClass"]
		//     -> LOAD_GLOBAL name_index
		if e.Name == "self" {
			// Special case: self keyword
			c.emit(bytecode.OpPushSelf, 0)
		} else if idx, ok := c.findLocalVar(e.Name); ok {
			// It's a local variable
			c.emit(bytecode.OpLoadLocal, idx)
		} else if idx, ok := c.fields[e.Name]; ok {
			// It's an instance variable (field)
			c.emit(bytecode.OpLoadField, idx)
		} else if idx, ok := c.classVars[e.Name]; ok {
			// It's a class variable
			c.emit(bytecode.OpLoadClassVar, idx)
		} else {
			// It's a global variable - add the name to constants
			idx := c.addConstant(e.Name)
			c.emit(bytecode.OpLoadGlobal, idx)
		}
		return nil

	case *ast.Assignment:
		// Assignments evaluate the right-hand side and store the result
		// to a variable.
		//
		// Process:
		//   1. Compile the value expression (leaves value on stack)
		//   2. Emit STORE instruction (pops value, stores it, pushes back)
		//
		// The value is pushed back because assignments are expressions
		// that return their value: (x := 5) evaluates to 5.
		//
		// Example: x := 10
		//   -> PUSH 10          ; load the value
		//   -> STORE_LOCAL 0    ; store to x, value stays on stack

		// Step 1: Compile the value expression
		if err := c.compileExpression(e.Value); err != nil {
			return err
		}

		// Step 2: Store to the variable
		// Check if it's local, field, class variable, or global
		if idx, ok := c.findLocalVar(e.Name); ok {
			c.emit(bytecode.OpStoreLocal, idx)
		} else if idx, ok := c.fields[e.Name]; ok {
			// It's an instance variable (field)
			c.emit(bytecode.OpStoreField, idx)
		} else if idx, ok := c.classVars[e.Name]; ok {
			// It's a class variable
			c.emit(bytecode.OpStoreClassVar, idx)
		} else {
			// Store as global
			nameIdx := c.addConstant(e.Name)
			c.emit(bytecode.OpStoreGlobal, nameIdx)
		}
		return nil

	case *ast.MessageSend:
		// Message sends are the core operation in smog. They implement
		// method calls, operator invocations, and all inter-object communication.
		//
		// Compilation process:
		//   1. Compile receiver (pushes receiver on stack) - unless it's a super send
		//   2. Compile each argument (pushes args on stack)
		//   3. Emit SEND or SUPER_SEND with selector and arg count
		//
		// Example: receiver selector: arg1 with: arg2
		//
		// Stack evolution:
		//   [receiver]                 ; after compiling receiver
		//   [receiver, arg1]           ; after compiling arg1
		//   [receiver, arg1, arg2]     ; after compiling arg2
		//   [result]                   ; after SEND pops args and receiver, pushes result
		//
		// For super sends:
		//   The receiver is implicitly self, and we use SUPER_SEND instead
		//   of SEND to start method lookup in the superclass.
		//
		// The SEND/SUPER_SEND instruction's operand encodes:
		//   - Selector index (high bits): where to find the selector in constants
		//   - Argument count (low 8 bits): how many args to pop from stack

		// Step 1: Compile the receiver expression (unless it's a super send)
		if e.IsSuper {
			// For super sends, push self as the receiver
			c.emit(bytecode.OpPushSelf, 0)
		} else {
			if err := c.compileExpression(e.Receiver); err != nil {
				return err
			}
		}

		// Step 2: Compile all arguments in order
		for _, arg := range e.Args {
			if err := c.compileExpression(arg); err != nil {
				return err
			}
		}

		// Step 3: Emit the SEND or SUPER_SEND instruction
		// Add the selector to the constant pool
		selectorIdx := c.addConstant(e.Selector)
		argCount := len(e.Args)

		// Pack selector index and arg count into a single operand
		// High bits: selector index
		// Low 8 bits: argument count
		operand := (selectorIdx << bytecode.SelectorIndexShift) | argCount
		
		if e.IsSuper {
			c.emit(bytecode.OpSuperSend, operand)
		} else {
			c.emit(bytecode.OpSend, operand)
		}
		return nil

	case *ast.BlockLiteral:
		// Block literals compile to closures.
		//
		// Process:
		//   1. Create a new compiler for the block body
		//   2. Compile the block body to separate bytecode
		//   3. Add the bytecode to the constant pool
		//   4. Emit MAKE_CLOSURE instruction
		//
		// The block captures the current environment (closure).
		//
		// Example: [ :x | x + 1 ]
		//   -> Bytecode for block body stored in constants
		//   -> MAKE_CLOSURE block_idx, 1  (1 parameter)
		return c.compileBlockLiteral(e)

	case *ast.ArrayLiteral:
		// Array literals compile to a sequence of element pushes
		// followed by a MAKE_ARRAY instruction.
		//
		// Process:
		//   1. Compile each element expression
		//   2. Emit MAKE_ARRAY with element count
		//
		// Example: #(1 2 3)
		//   -> PUSH 1
		//   -> PUSH 2
		//   -> PUSH 3
		//   -> MAKE_ARRAY 3
		
		// Compile each element
		for _, elem := range e.Elements {
			if err := c.compileExpression(elem); err != nil {
				return err
			}
		}
		
		// Emit MAKE_ARRAY instruction
		c.emit(bytecode.OpMakeArray, len(e.Elements))
		return nil

	case *ast.DictionaryLiteral:
		// Dictionary literals compile to a sequence of key-value pushes
		// followed by a MAKE_DICTIONARY instruction.
		//
		// Process:
		//   1. Compile each key expression
		//   2. Compile each value expression
		//   3. Emit MAKE_DICTIONARY with pair count
		//
		// Example: #{'name' -> 'Alice'. 'age' -> 30}
		//   -> PUSH 'name'
		//   -> PUSH 'Alice'
		//   -> PUSH 'age'
		//   -> PUSH 30
		//   -> MAKE_DICTIONARY 2
		//
		// Stack evolution:
		//   []
		//   ['name']
		//   ['name', 'Alice']
		//   ['name', 'Alice', 'age']
		//   ['name', 'Alice', 'age', 30]
		//   [dictionary]  ; MAKE_DICTIONARY pops 4 elements and pushes dictionary
		for _, pair := range e.Pairs {
			if err := c.compileExpression(pair.Key); err != nil {
				return err
			}
			if err := c.compileExpression(pair.Value); err != nil {
				return err
			}
		}
		c.emit(bytecode.OpMakeDictionary, len(e.Pairs))
		return nil

	case *ast.CascadeExpression:
		// Cascade expressions send multiple messages to the same receiver.
		//
		// Syntax: receiver msg1; msg2; msg3
		//
		// The cascade returns the receiver itself, not the result of any message.
		//
		// Compilation strategy:
		//   1. Compile receiver -> [receiver]
		//   2. For each message:
		//      a. DUP receiver -> [receiver, receiver]
		//      b. Compile args -> [receiver, receiver, arg1, arg2, ...]
		//      c. SEND -> [receiver, result]
		//      d. POP result -> [receiver]
		//   3. Final stack has receiver as result
		//
		// Example: point x: 10; y: 20
		//   PUSH point     ; [point]
		//   DUP            ; [point, point]
		//   PUSH 10        ; [point, point, 10]
		//   SEND x:, 1     ; [point, result]
		//   POP            ; [point]
		//   DUP            ; [point, point]
		//   PUSH 20        ; [point, point, 20]
		//   SEND y:, 1     ; [point, result]
		//   POP            ; [point]
		//   ; Final: point is on stack
		
		// Step 1: Compile and push the receiver
		if err := c.compileExpression(e.Receiver); err != nil {
			return err
		}
		
		// Step 2: For each message in the cascade
		for _, msg := range e.Messages {
			// Duplicate the receiver so we can send a message to it
			c.emit(bytecode.OpDup, 0)
			
			// Compile message arguments
			for _, arg := range msg.Args {
				if err := c.compileExpression(arg); err != nil {
					return err
				}
			}
			
			// Emit the SEND instruction
			selectorIdx := c.addConstant(msg.Selector)
			argCount := len(msg.Args)
			operand := (selectorIdx << bytecode.SelectorIndexShift) | argCount
			
			if msg.IsSuper {
				c.emit(bytecode.OpSuperSend, operand)
			} else {
				c.emit(bytecode.OpSend, operand)
			}
			
			// Pop the result - we don't need it, we want the receiver
			c.emit(bytecode.OpPop, 0)
		}
		
		// The receiver is now on top of the stack as the result
		return nil

	default:
		return fmt.Errorf("unknown expression type: %T", expr)
	}
}

// compileBlockLiteral compiles a block literal into a closure.
//
// Blocks are compiled as separate bytecode units that are stored in the
// constant pool. The MAKE_CLOSURE instruction creates a closure object
// that captures the current environment.
//
// Parameters:
//   - block: The BlockLiteral AST node
//
// Returns:
//   - error if compilation fails
func (c *Compiler) compileBlockLiteral(block *ast.BlockLiteral) error {
	// Create a new compiler for the block body
	// This gives the block its own symbol table and instruction sequence
	blockCompiler := New()
	
	// Mark that we're compiling a block - this affects how return statements are compiled
	blockCompiler.inBlock = true
	
	// Blocks should have access to the same fields and class variables as the parent context
	// This allows blocks to access instance variables and class variables
	blockCompiler.fields = c.fields
	blockCompiler.classVars = c.classVars
	blockCompiler.classes = c.classes
	
	// Copy parent's local variables to support closures
	// NOTE: This is a temporary flat-copy approach that provides basic closure support
	// but doesn't implement true lexical scoping with environment chains.
	// See docs/LEXICAL_SCOPING_REVIEW.md for the full implementation plan.
	// Blocks can access variables from enclosing scope
	blockCompiler.localVars = append([]string{}, c.localVars...)
	blockCompiler.localCount = c.localCount
	
	// Capture parent's local count AFTER setting up local variables
	// This ensures consistency with the copied state
	parentLocalCount := blockCompiler.localCount
	
	// Add block parameters to the local variables
	// Parameters become local variables in the block, allocated after parent's locals
	for _, param := range block.Parameters {
		blockCompiler.localVars = append(blockCompiler.localVars, param)
		blockCompiler.localCount++
	}
	
	// Compile the block body statements
	for i, stmt := range block.Body {
		isLast := i == len(block.Body)-1
		if err := blockCompiler.compileStatementWithContext(stmt, isLast); err != nil {
			return err
		}
	}
	
	// Add return instruction at the end
	// Blocks return the value of their last expression
	blockCompiler.emit(bytecode.OpReturn, 0)
	
	// Create the bytecode for the block
	blockBytecode := &bytecode.Bytecode{
		Instructions: blockCompiler.instructions,
		Constants:    blockCompiler.constants,
	}
	
	// Add the block bytecode to the constant pool
	blockIdx := c.addConstant(blockBytecode)
	paramCount := len(block.Parameters)
	
	// Emit MAKE_CLOSURE instruction
	// Pack: block index (high bits) | parent local count (bits 8-15) | param count (bits 0-7)
	// This allows blocks to properly set up closure parameters
	operand := (blockIdx << 16) | (parentLocalCount << 8) | paramCount
	c.emit(bytecode.OpMakeClosure, operand)
	
	return nil
}

// emit adds a bytecode instruction to the instruction sequence.
//
// This is a helper method that constructs an Instruction and appends it
// to the growing bytecode sequence.
//
// Parameters:
//   - op: The opcode (what operation to perform)
//   - operand: Additional data for the instruction (meaning depends on op)
//
// Example:
//   c.emit(bytecode.OpPush, 5)
//     -> Appends Instruction{Op: OpPush, Operand: 5}
func (c *Compiler) emit(op bytecode.Opcode, operand int) {
	c.instructions = append(c.instructions, bytecode.Instruction{
		Op:      op,
		Operand: operand,
	})
}

// addConstant adds a value to the constant pool and returns its index.
//
// The constant pool stores all literal values and identifiers used in
// the program. Each constant is assigned an index (its position in the array).
// Instructions reference constants by this index.
//
// Parameters:
//   - obj: The value to add (can be int64, float64, string, etc.)
//
// Returns:
//   - The index where the constant was stored
//
// Example:
//   idx1 := c.addConstant(42)      // Returns 0
//   idx2 := c.addConstant("hello") // Returns 1
//   idx3 := c.addConstant(42)      // Returns 2 (duplicates are not deduplicated)
//
// Note: This implementation doesn't deduplicate constants. Each call adds
// a new entry. A production compiler might want to check for duplicates.
func (c *Compiler) addConstant(obj interface{}) int {
	c.constants = append(c.constants, obj)
	return len(c.constants) - 1
}

// CompileIncremental compiles a program while preserving the symbol table.
//
// This method is designed for REPL usage where variable declarations and
// assignments need to persist across multiple compilations. Unlike Compile(),
// which is intended for single-use compilation, CompileIncremental:
//   - Preserves the symbol table (local variable mappings)
//   - Resets the instruction list for each call
//   - Resets the constant pool for each call
//
// The symbol table (symbols map and localCount) persists across calls,
// allowing local variables declared in previous REPL inputs to remain
// accessible in subsequent inputs.
//
// Example REPL session:
//   Input 1: | x |     -> symbols["x"] = 0, localCount = 1
//   Input 2: x := 42.  -> Uses symbols["x"] = 0 (preserved from Input 1)
//   Input 3: x + 8.    -> Uses symbols["x"] = 0 (still preserved)
//
// Parameters:
//   - program: The AST program to compile
//
// Returns:
//   - Bytecode with instructions and constants
//   - Error if compilation fails
func (c *Compiler) CompileIncremental(program *ast.Program) (*bytecode.Bytecode, error) {
	// Reset instructions and constants for this compilation
	// but preserve symbols and localCount
	// Use slice reuse pattern to preserve capacity for better performance
	c.instructions = c.instructions[:0]
	c.constants = c.constants[:0]
	
	// Compile each statement in order
	for i, stmt := range program.Statements {
		isLast := i == len(program.Statements)-1
		if err := c.compileStatementWithContext(stmt, isLast); err != nil {
			return nil, err
		}
	}

	// Add final return instruction to end the program
	c.emit(bytecode.OpReturn, 0)

	return &bytecode.Bytecode{
		Instructions: c.instructions,
		Constants:    c.constants,
	}, nil
}

// compileClass compiles a class definition.
//
// A class definition consists of:
//   - Name and superclass
//   - Instance variables (fields)
//   - Class variables
//   - Methods (both instance and class methods)
//
// The compiler creates a ClassDefinition containing all this information,
// adds it to the constant pool, and emits a DEFINE_CLASS instruction.
//
// Each method is compiled separately into its own bytecode, which is
// stored in the MethodDefinition within the ClassDefinition.
//
// Example:
//   Object subclass: #Counter [
//       | count |
//       initialize [ count := 0. ]
//       increment [ count := count + 1. ]
//   ]
//
// This compiles to:
//   1. Create bytecode for initialize method
//   2. Create bytecode for increment method
//   3. Create ClassDefinition with both methods
//   4. Add ClassDefinition to constants at index N
//   5. Emit DEFINE_CLASS N
func (c *Compiler) compileClass(class *ast.Class) error {
	// Collect all fields (inherited + own) for method compilation
	allFields := c.getAllFields(class.SuperClass, class.Fields)
	
	// Compile instance methods
	instanceMethods := make([]*bytecode.MethodDefinition, 0, len(class.Methods))
	for _, method := range class.Methods {
		methodDef, err := c.compileMethod(method, allFields, class.ClassVariables)
		if err != nil {
			return fmt.Errorf("failed to compile method %s: %w", method.Name, err)
		}
		instanceMethods = append(instanceMethods, methodDef)
	}

	// Compile class methods
	classMethods := make([]*bytecode.MethodDefinition, 0, len(class.ClassMethods))
	for _, method := range class.ClassMethods {
		methodDef, err := c.compileMethod(method, nil, class.ClassVariables)
		if err != nil {
			return fmt.Errorf("failed to compile class method %s: %w", method.Name, err)
		}
		classMethods = append(classMethods, methodDef)
	}

	// Create the class definition
	classDef := &bytecode.ClassDefinition{
		Name:           class.Name,
		SuperClass:     class.SuperClass,
		Fields:         class.Fields,
		ClassVariables: class.ClassVariables,
		ClassVarValues: make(map[string]interface{}), // Initialize class variable storage
		Methods:        instanceMethods,
		ClassMethods:   classMethods,
	}

	// Register this class so subclasses can access it
	c.classes[class.Name] = classDef

	// Add class definition to constant pool
	idx := c.addConstant(classDef)

	// Emit DEFINE_CLASS instruction
	c.emit(bytecode.OpDefineClass, idx)

	return nil
}

// getAllFields returns all fields for a class including inherited fields.
// Fields are ordered from superclass to subclass to match runtime layout.
func (c *Compiler) getAllFields(superClassName string, ownFields []string) []string {
	var allFields []string
	
	// Collect superclass fields first
	if superClassName != "" && superClassName != "Object" {
		if superClass, exists := c.classes[superClassName]; exists {
			// Recursively get all superclass fields
			allFields = c.getAllFields(superClass.SuperClass, superClass.Fields)
		}
	}
	
	// Add this class's fields
	allFields = append(allFields, ownFields...)
	
	return allFields
}

// compileMethod compiles a method definition into bytecode.
//
// A method is compiled in its own scope with:
//   - Parameters as local variables (starting at index 0)
//   - Instance variables accessible via OpLoadField/OpStoreField
//   - Class variables accessible via OpLoadClassVar/OpStoreClassVar
//   - Method body statements compiled sequentially
//   - Implicit return of self if no explicit return
//
// Example:
//   increment [ count := count + 1. ]
//
// Compiles to:
//   LOAD_FIELD 0      ; load count (assuming it's field 0)
//   PUSH 1            ; constant 1
//   SEND +, 1         ; send + message
//   STORE_FIELD 0     ; store back to count
//   PUSH_SELF         ; implicit return self
//   RETURN
func (c *Compiler) compileMethod(method *ast.Method, fields []string, classVars []string) (*bytecode.MethodDefinition, error) {
	// Create a new compiler for the method body to have its own scope
	methodCompiler := New()

	// Parameters become local variables (in order)
	for _, param := range method.Parameters {
		methodCompiler.localVars = append(methodCompiler.localVars, param)
		methodCompiler.localCount++
	}

	// Build a map of field names to indices for field access
	if fields != nil {
		fieldMap := make(map[string]int)
		for i, field := range fields {
			fieldMap[field] = i
		}
		methodCompiler.fields = fieldMap
	}

	// Build a map of class variable names to indices
	if classVars != nil {
		classVarMap := make(map[string]int)
		for i, classVar := range classVars {
			classVarMap[classVar] = i
		}
		methodCompiler.classVars = classVarMap
	}

	// Compile method body
	for i, stmt := range method.Body {
		isLast := i == len(method.Body)-1
		if err := methodCompiler.compileStatementWithContext(stmt, isLast); err != nil {
			return nil, err
		}
	}

	// Add implicit return of self if the last statement wasn't a return
	// Check if we need to add implicit return
	if len(methodCompiler.instructions) == 0 ||
		methodCompiler.instructions[len(methodCompiler.instructions)-1].Op != bytecode.OpReturn {
		methodCompiler.emit(bytecode.OpPushSelf, 0)
		methodCompiler.emit(bytecode.OpReturn, 0)
	}

	// Create method definition with compiled bytecode
	methodDef := &bytecode.MethodDefinition{
		Selector:   method.Name,
		Parameters: method.Parameters,
		Code: &bytecode.Bytecode{
			Instructions: methodCompiler.instructions,
			Constants:    methodCompiler.constants,
		},
	}

	return methodDef, nil
}

// findLocalVar searches for a local variable by name and returns its index.
// Returns the index and true if found, -1 and false otherwise.
func (c *Compiler) findLocalVar(name string) (int, bool) {
	for i, varName := range c.localVars {
		if varName == name {
			return i, true
		}
	}
	return -1, false
}
