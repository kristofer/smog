// Package compiler compiles AST nodes into bytecode.
//
// The compiler is the bridge between the high-level AST (Abstract Syntax Tree)
// representation and the low-level bytecode that the VM executes. It performs
// several key tasks:
//
//   1. Traverse the AST tree structure
//   2. Generate bytecode instructions for each node
//   3. Manage the constant pool (literals and identifiers)
//   4. Track variable declarations (symbol table)
//   5. Emit appropriate opcodes for each language construct
//
// Compilation Process:
//
//   Source Code → Lexer → Parser → AST → Compiler → Bytecode → VM
//
// The compiler walks the AST and emits a linear sequence of instructions.
// For example:
//
//   Source: | x | x := 5. x + 3.
//
//   AST:
//     Program
//       ├─ VariableDeclaration: ["x"]
//       ├─ ExpressionStatement
//       │   └─ Assignment: name="x", value=IntegerLiteral(5)
//       └─ ExpressionStatement
//           └─ MessageSend: receiver=Identifier("x"), selector="+", args=[IntegerLiteral(3)]
//
//   Bytecode:
//     PUSH 0          ; constant[0] = 5
//     STORE_LOCAL 0   ; x is at local slot 0
//     LOAD_LOCAL 0    ; load x
//     PUSH 1          ; constant[1] = 3
//     SEND 2, 1       ; constant[2] = "+", 1 argument
//     RETURN
//
//   Constants: [5, 3, "+"]
//
// Key Concepts:
//
// Symbol Table:
//   Maps variable names to local variable slot indices. When a variable is
//   declared with `| x y |`, the compiler assigns slots: x=0, y=1.
//
// Constant Pool:
//   Stores all literal values (numbers, strings) and identifiers (selectors,
//   global names) used in the program. Instructions reference these by index.
//
// Stack-Based Code Generation:
//   Most operations assume their operands are on the stack. For example,
//   `x + y` compiles to: LOAD x, LOAD y, SEND +
//
// Expression vs Statement Compilation:
//   Both produce values on the stack, but statement results may be discarded
//   if not needed.
package compiler

import (
	"fmt"

	"github.com/kristofer/smog/pkg/ast"
	"github.com/kristofer/smog/pkg/bytecode"
)

// Compiler represents the bytecode compiler.
//
// The compiler maintains state during compilation:
//   - instructions: The growing sequence of bytecode instructions
//   - constants: The constant pool of literal values
//   - symbols: Symbol table mapping variable names to local slots
//   - localCount: Number of local variables allocated so far
//
// The compiler is stateful and single-use: create a new compiler for
// each compilation unit (program, method, block).
type Compiler struct {
	instructions []bytecode.Instruction // Generated bytecode instructions
	constants    []interface{}          // Constant pool (literals, names)
	symbols      map[string]int         // Symbol table: name -> local slot index
	localCount   int                    // Next available local variable slot
}

// New creates a new compiler instance.
//
// Each compilation starts with a fresh compiler that has:
//   - Empty instruction sequence
//   - Empty constant pool
//   - Empty symbol table
//   - Zero local variables
func New() *Compiler {
	return &Compiler{
		instructions: make([]bytecode.Instruction, 0),
		constants:    make([]interface{}, 0),
		symbols:      make(map[string]int),
		localCount:   0,
	}
}

// Compile compiles an AST program into bytecode.
//
// This is the main entry point for compilation. It:
//   1. Processes each statement in the program sequentially
//   2. Emits bytecode for each statement
//   3. Adds a final RETURN instruction to end execution
//   4. Returns the complete Bytecode with instructions and constants
//
// Example:
//
//   parser := parser.New("3 + 4.")
//   program, _ := parser.Parse()
//   compiler := compiler.New()
//   bytecode, _ := compiler.Compile(program)
//
// The resulting bytecode can then be executed by the VM.
//
// Returns an error if any statement fails to compile (e.g., unknown node type).
func (c *Compiler) Compile(program *ast.Program) (*bytecode.Bytecode, error) {
	// Compile each statement in order
	for _, stmt := range program.Statements {
		if err := c.compileStatement(stmt); err != nil {
			return nil, err
		}
	}

	// Add final return instruction to end the program
	c.emit(bytecode.OpReturn, 0)

	return &bytecode.Bytecode{
		Instructions: c.instructions,
		Constants:    c.constants,
	}, nil
}

// compileStatement compiles a single statement node.
//
// Statements are top-level constructs in the AST. Each type of statement
// has different compilation requirements:
//
//   - ExpressionStatement: Compile the expression (leaves value on stack)
//   - VariableDeclaration: Register variables in symbol table (no bytecode)
//   - ReturnStatement: Compile return value and emit RETURN instruction
//
// Future statement types might include:
//   - Class definitions
//   - Method definitions
//   - Import statements
func (c *Compiler) compileStatement(stmt ast.Statement) error {
	switch s := stmt.(type) {
	case *ast.ExpressionStatement:
		// Compile the wrapped expression
		// The result will be left on the stack
		return c.compileExpression(s.Expression)

	case *ast.VariableDeclaration:
		// Variable declarations don't generate bytecode directly.
		// They just reserve space in the local variable array and
		// update the symbol table so future references can be resolved.
		//
		// Example: | x y z |
		//   -> symbols["x"] = 0, symbols["y"] = 1, symbols["z"] = 2
		//   -> localCount = 3
		//
		// The variables are initialized to nil at runtime.
		for _, name := range s.Names {
			c.symbols[name] = c.localCount
			c.localCount++
		}
		return nil

	case *ast.ReturnStatement:
		// Return statements compile the return value and emit RETURN.
		//
		// Process:
		//   1. Compile the return value expression
		//   2. Emit RETURN instruction
		//
		// The value will be on the stack when RETURN executes,
		// and the VM will use it as the method/block result.
		//
		// Example: ^count + 1
		//   -> compile "count + 1" (leaves result on stack)
		//   -> RETURN
		if err := c.compileExpression(s.Value); err != nil {
			return err
		}
		c.emit(bytecode.OpReturn, 0)
		return nil

	default:
		return fmt.Errorf("unknown statement type: %T", stmt)
	}
}

// compileExpression compiles an expression node.
//
// Expressions produce values. When compiled, they generate bytecode that
// evaluates the expression and leaves the result on the stack.
//
// The compiler handles each expression type differently:
//
//   Literals:
//     Add the value to the constant pool and emit PUSH instruction
//     Example: 42 -> PUSH index_of_42_in_constants
//
//   Identifiers:
//     Look up in symbol table and emit LOAD instruction
//     Example: x -> LOAD_LOCAL 0 (if x is local slot 0)
//
//   Assignments:
//     Compile the value expression, then emit STORE instruction
//     Example: x := 5 -> PUSH 5; STORE_LOCAL 0
//
//   Message Sends:
//     Compile receiver, compile arguments, emit SEND instruction
//     Example: 3 + 4 -> PUSH 3; PUSH 4; SEND +, 1
//
//   Blocks:
//     Create a separate bytecode for the block body, add to constants
//     Example: [ x + 1 ] -> MAKE_CLOSURE block_index, 0
//
// All expression compilation follows the pattern:
//   1. Compile sub-expressions (leaves values on stack)
//   2. Emit operation instruction
//   3. Result is left on stack for parent expression/statement
func (c *Compiler) compileExpression(expr ast.Expression) error {
	switch e := expr.(type) {
	case *ast.IntegerLiteral:
		// Integer literals are stored in the constant pool.
		// We add the value to the pool and emit a PUSH instruction
		// with the index.
		//
		// Example: 42
		//   -> constants = [42]
		//   -> PUSH 0
		idx := c.addConstant(e.Value)
		c.emit(bytecode.OpPush, idx)
		return nil

	case *ast.FloatLiteral:
		// Float literals work the same as integers.
		//
		// Example: 3.14
		//   -> constants = [3.14]
		//   -> PUSH 0
		idx := c.addConstant(e.Value)
		c.emit(bytecode.OpPush, idx)
		return nil

	case *ast.StringLiteral:
		// String literals are also stored in the constant pool.
		//
		// Example: 'Hello'
		//   -> constants = ["Hello"]
		//   -> PUSH 0
		idx := c.addConstant(e.Value)
		c.emit(bytecode.OpPush, idx)
		return nil

	case *ast.BooleanLiteral:
		// Boolean literals use specialized instructions for efficiency.
		// Instead of adding true/false to the constant pool, we use
		// dedicated opcodes.
		//
		// This saves space (no constant pool entry) and is faster
		// (no constant pool lookup at runtime).
		if e.Value {
			c.emit(bytecode.OpPushTrue, 0)
		} else {
			c.emit(bytecode.OpPushFalse, 0)
		}
		return nil

	case *ast.NilLiteral:
		// Nil also uses a specialized instruction.
		c.emit(bytecode.OpPushNil, 0)
		return nil

	case *ast.Identifier:
		// Identifiers refer to variables. We look up the variable in
		// the symbol table to determine if it's local or global.
		//
		// Local variables:
		//   Stored in the symbol table with their slot index
		//   Example: x (where x was declared as | x |)
		//     -> LOAD_LOCAL slot_index
		//
		// Global variables:
		//   Not in the symbol table (not declared locally)
		//   Example: SomeClass
		//     -> constants = ["SomeClass"]
		//     -> LOAD_GLOBAL name_index
		if idx, ok := c.symbols[e.Name]; ok {
			// It's a local variable
			c.emit(bytecode.OpLoadLocal, idx)
		} else {
			// It's a global variable - add the name to constants
			idx := c.addConstant(e.Name)
			c.emit(bytecode.OpLoadGlobal, idx)
		}
		return nil

	case *ast.Assignment:
		// Assignments evaluate the right-hand side and store the result
		// to a variable.
		//
		// Process:
		//   1. Compile the value expression (leaves value on stack)
		//   2. Emit STORE instruction (pops value, stores it, pushes back)
		//
		// The value is pushed back because assignments are expressions
		// that return their value: (x := 5) evaluates to 5.
		//
		// Example: x := 10
		//   -> PUSH 10          ; load the value
		//   -> STORE_LOCAL 0    ; store to x, value stays on stack

		// Step 1: Compile the value expression
		if err := c.compileExpression(e.Value); err != nil {
			return err
		}

		// Step 2: Store to the variable
		// Check if it's local or global (same logic as Identifier)
		if idx, ok := c.symbols[e.Name]; ok {
			c.emit(bytecode.OpStoreLocal, idx)
		} else {
			// Store as global
			nameIdx := c.addConstant(e.Name)
			c.emit(bytecode.OpStoreGlobal, nameIdx)
		}
		return nil

	case *ast.MessageSend:
		// Message sends are the core operation in smog. They implement
		// method calls, operator invocations, and all inter-object communication.
		//
		// Compilation process:
		//   1. Compile receiver (pushes receiver on stack)
		//   2. Compile each argument (pushes args on stack)
		//   3. Emit SEND with selector and arg count
		//
		// Example: receiver selector: arg1 with: arg2
		//
		// Stack evolution:
		//   [receiver]                 ; after compiling receiver
		//   [receiver, arg1]           ; after compiling arg1
		//   [receiver, arg1, arg2]     ; after compiling arg2
		//   [result]                   ; after SEND pops args and receiver, pushes result
		//
		// The SEND instruction's operand encodes:
		//   - Selector index (high bits): where to find the selector in constants
		//   - Argument count (low 8 bits): how many args to pop from stack

		// Step 1: Compile the receiver expression
		if err := c.compileExpression(e.Receiver); err != nil {
			return err
		}

		// Step 2: Compile all arguments in order
		for _, arg := range e.Args {
			if err := c.compileExpression(arg); err != nil {
				return err
			}
		}

		// Step 3: Emit the SEND instruction
		// Add the selector to the constant pool
		selectorIdx := c.addConstant(e.Selector)
		argCount := len(e.Args)

		// Pack selector index and arg count into a single operand
		// High bits: selector index
		// Low 8 bits: argument count
		operand := (selectorIdx << bytecode.SelectorIndexShift) | argCount
		c.emit(bytecode.OpSend, operand)
		return nil

	case *ast.BlockLiteral:
		// Block literals compile to closures.
		//
		// Process:
		//   1. Create a new compiler for the block body
		//   2. Compile the block body to separate bytecode
		//   3. Add the bytecode to the constant pool
		//   4. Emit MAKE_CLOSURE instruction
		//
		// The block captures the current environment (closure).
		//
		// Example: [ :x | x + 1 ]
		//   -> Bytecode for block body stored in constants
		//   -> MAKE_CLOSURE block_idx, 1  (1 parameter)
		return c.compileBlockLiteral(e)

	case *ast.ArrayLiteral:
		// Array literals compile to a sequence of element pushes
		// followed by a MAKE_ARRAY instruction.
		//
		// Process:
		//   1. Compile each element expression
		//   2. Emit MAKE_ARRAY with element count
		//
		// Example: #(1 2 3)
		//   -> PUSH 1
		//   -> PUSH 2
		//   -> PUSH 3
		//   -> MAKE_ARRAY 3
		
		// Compile each element
		for _, elem := range e.Elements {
			if err := c.compileExpression(elem); err != nil {
				return err
			}
		}
		
		// Emit MAKE_ARRAY instruction
		c.emit(bytecode.OpMakeArray, len(e.Elements))
		return nil

	default:
		return fmt.Errorf("unknown expression type: %T", expr)
	}
}

// compileBlockLiteral compiles a block literal into a closure.
//
// Blocks are compiled as separate bytecode units that are stored in the
// constant pool. The MAKE_CLOSURE instruction creates a closure object
// that captures the current environment.
//
// Parameters:
//   - block: The BlockLiteral AST node
//
// Returns:
//   - error if compilation fails
func (c *Compiler) compileBlockLiteral(block *ast.BlockLiteral) error {
	// Create a new compiler for the block body
	// This gives the block its own symbol table and instruction sequence
	blockCompiler := New()
	
	// Add block parameters to the symbol table
	// Parameters become local variables in the block
	for _, param := range block.Parameters {
		blockCompiler.symbols[param] = blockCompiler.localCount
		blockCompiler.localCount++
	}
	
	// Compile the block body statements
	for _, stmt := range block.Body {
		if err := blockCompiler.compileStatement(stmt); err != nil {
			return err
		}
	}
	
	// Add return instruction at the end
	// Blocks return the value of their last expression
	blockCompiler.emit(bytecode.OpReturn, 0)
	
	// Create the bytecode for the block
	blockBytecode := &bytecode.Bytecode{
		Instructions: blockCompiler.instructions,
		Constants:    blockCompiler.constants,
	}
	
	// Add the block bytecode to the constant pool
	blockIdx := c.addConstant(blockBytecode)
	paramCount := len(block.Parameters)
	
	// Emit MAKE_CLOSURE instruction
	// Pack block index and parameter count
	operand := (blockIdx << bytecode.SelectorIndexShift) | paramCount
	c.emit(bytecode.OpMakeClosure, operand)
	
	return nil
}

// emit adds a bytecode instruction to the instruction sequence.
//
// This is a helper method that constructs an Instruction and appends it
// to the growing bytecode sequence.
//
// Parameters:
//   - op: The opcode (what operation to perform)
//   - operand: Additional data for the instruction (meaning depends on op)
//
// Example:
//   c.emit(bytecode.OpPush, 5)
//     -> Appends Instruction{Op: OpPush, Operand: 5}
func (c *Compiler) emit(op bytecode.Opcode, operand int) {
	c.instructions = append(c.instructions, bytecode.Instruction{
		Op:      op,
		Operand: operand,
	})
}

// addConstant adds a value to the constant pool and returns its index.
//
// The constant pool stores all literal values and identifiers used in
// the program. Each constant is assigned an index (its position in the array).
// Instructions reference constants by this index.
//
// Parameters:
//   - obj: The value to add (can be int64, float64, string, etc.)
//
// Returns:
//   - The index where the constant was stored
//
// Example:
//   idx1 := c.addConstant(42)      // Returns 0
//   idx2 := c.addConstant("hello") // Returns 1
//   idx3 := c.addConstant(42)      // Returns 2 (duplicates are not deduplicated)
//
// Note: This implementation doesn't deduplicate constants. Each call adds
// a new entry. A production compiler might want to check for duplicates.
func (c *Compiler) addConstant(obj interface{}) int {
	c.constants = append(c.constants, obj)
	return len(c.constants) - 1
}
